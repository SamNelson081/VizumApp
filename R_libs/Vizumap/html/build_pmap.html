<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Build a pixel map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for build_pmap {Vizumap}"><tr><td>build_pmap {Vizumap}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Build a pixel map</h2>

<h3>Description</h3>

<p>This function builds a choropleth map that visualises estimates and errors
simultaneously through pixelation and sampling.
</p>


<h3>Usage</h3>

<pre>
build_pmap(
  data = NULL,
  distribution = NULL,
  pixelGeo,
  id,
  border = NULL,
  palette = "Blues",
  q = NULL,
  limits = NULL
)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr valign="top"><td><code>distribution</code></td>
<td>
<p>Name of the distribution that the pixel assignments will
be drawn from. It must be one of <code>discrete</code>, <code>normal</code> or
<code>uniform</code>. If <code>distribution = "discrete"</code>, a data frame of the
quantiles that define the relative frequency distribution for the
estimate must be entered for <code>q</code>. If <code>distribution = "normal"</code>,
the values assigned to pixels will be drawn from a normal distribution
parameterised using the estimates and errors (means and standard
deviations). If <code>distribution = "uniform"</code>, values will be sampled with
equal probability from a sequence of 5 numbers that spans the estimate minus
its error to the estimate plus its error.</p>
</td></tr>
<tr valign="top"><td><code>pixelGeo</code></td>
<td>
<p>An object from <code><a href="pixelate.html">pixelate</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>id</code></td>
<td>
<p>Name of the common column shared by the objects passed to
<code>data</code>, <code>pixelGeo</code> and <code>q</code> (if <code>distribution =
"discrete"</code>).</p>
</td></tr>
<tr valign="top"><td><code>border</code></td>
<td>
<p>Name of geographical borders to be added to the map. It must be
one of <code><a href="../../maps/html/county.html">county</a></code>, <code><a href="../../maps/html/france.html">france</a></code>,
<code><a href="../../maps/html/italy.html">italy</a></code>, <code><a href="../../maps/html/nz.html">nz</a></code>,
<code><a href="../../maps/html/state.html">state</a></code>, <code><a href="../../maps/html/usa.html">usa</a></code> or
<code><a href="../../maps/html/world.html">world</a></code> (see documentation for
<code><a href="../../ggplot2/html/map_data.html">map_data</a></code> for more information). The borders will be
refined to match latitute and longtidue coordinates provided in the data
frame or spatial polygons data frame. Alternatively, you can supply a <code>SpatialPolygonsDataFrame</code>.</p>
</td></tr>
<tr valign="top"><td><code>palette</code></td>
<td>
<p>Name of colour palette. It must be one of <code>Blues</code>,
<code>Greens</code>, <code>Greys</code>, <code>Oranges</code>, <code>Purples</code> or <code>Reds</code>
(see documentation for <code><a href="../../ggplot2/html/scale_fill_distiller.html">scale_fill_distiller</a></code> for more
information).</p>
</td></tr>
<tr valign="top"><td><code>q</code></td>
<td>
<p>A data frame of quantiles which define the distribution for each
estimate. Each row is an estimate, and each column is a quantile. See
examples for an example of <code>q</code> input.</p>
</td></tr>
<tr valign="top"><td><code>limits</code></td>
<td>
<p>Limits for the legend. Default is NULL, which takes the limits to be the range of the data.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="animate.html">animate</a></code>
</p>


<h3>Examples</h3>

<pre>
# This code will produce a pixelated map when run in R
# It is not run here.
#data(us_geo)
#ca_geo &lt;- subset(us_geo, us_geo@data$STATE == "06")
#pix &lt;- pixelate(ca_geo, id = "region")

#data(us_data)
#us_data$GEO.id2 &lt;- as.numeric(us_data$GEO.id2)
#ca_data &lt;- subset(us_data, us_data$GEO.id2 &gt; 6000 &amp; us_data$GEO.id2 &lt; 7000)
#ca_data &lt;- read.uv(data = ca_data, estimate = "pov_rate", error = "pov_moe")
#row.names(ca_data) &lt;- seq(1, nrow(ca_data), 1)

#df &lt;- data.frame(region = sapply(slot(ca_geo, "polygons"),
#  function(x) slot(x, "ID")), name = unique(ca_geo@data$GEO_ID))
#ca_data$region &lt;- df[match(ca_data$GEO_ID, df$name), 1]
#ca_data$region &lt;- as.character(ca_data$region)

#uniform distribution
#m &lt;- build_pmap(data = ca_data, distribution = "uniform", pixelGeo = pix, id = "region")
#view(m)

#normal distribution
#ca_data$se &lt;- ca_data$pov_moe / 1.645
#ca_data &lt;- read.uv(data = ca_data, estimate = "pov_rate", error = "se")

#m &lt;- build_pmap(data = ca_data, distribution = "normal", pixelGeo = pix, id = "region")
#view(m)

#experiment with discrete distribution
#exponential - example for q argument
#ca_data.q &lt;- with(ca_data, data.frame(p0.05 = qexp(0.05, 1/pov_rate),
#  p0.25 = qexp(0.25, 1/pov_rate), p0.5 = qexp(0.5, 1/pov_rate),
#  p0.75 = qexp(0.75, 1/pov_rate), p0.95 = qexp(0.95, 1/pov_rate)))

#m &lt;- build_pmap(data = ca_data, distribution = "discrete", pixelGeo = pix,
#  id = "region", q = ca_data.q)
#view(m)

</pre>

<hr /><div style="text-align: center;">[Package <em>Vizumap</em> version 1.2.0 <a href="00Index.html">Index</a>]</div>
</body></html>
